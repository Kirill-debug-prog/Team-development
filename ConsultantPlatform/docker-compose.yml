version '3.8' # Используем одну из последних версий синтаксиса

services
  # Сервис базы данных PostgreSQL
  db
    image postgres16 # Или другая нужная версия PostgreSQL, например postgres15
    container_name consultant-db # Имя контейнера для удобства
    restart unless-stopped # Перезапускать контейнер, если он остановился (кроме случая ручной остановки)
    environment
      # Учетные данные для PostgreSQL. Должны совпадать с ConnectionString в API!
      POSTGRES_USER admin
      POSTGRES_PASSWORD admin # ВАЖНО Для реальных проектов используйте более безопасные способы передачи пароля (секреты, .env файлы)
      POSTGRES_DB menti # Имя базы данных, которую нужно создать при первом запуске
    volumes
      # Создаем именованный том для хранения данных PostgreSQL между перезапусками контейнера
      - postgres_datavarlibpostgresqldata
    ports
      # Пробрасываем порт БД на хост-машину (опционально, если нужен прямой доступ к БД извне Docker)
      # Формат порт_на_хостепорт_в_контейнере
      # Используем 5433 на хосте, чтобы не конфликтовать с локальным PostgreSQL (если он есть на 5432)
      - 54335432
    healthcheck
      # Проверка готовности базы данных перед запуском API
      test [CMD-SHELL, pg_isready -U admin -d menti]
      interval 10s
      timeout 5s
      retries 5

  # Сервис вашего API (бэкенда)
  api
    container_name consultant-api
    # Указываем Docker собрать образ из текущей папки (.) используя Dockerfile
    build
      context .
      dockerfile Dockerfile
    restart unless-stopped
    ports
      # Пробрасываем порт API (8080 внутри контейнера, как задано в Dockerfile) на порт хоста (например, 5001)
      - 50018080
    environment
      # Переопределяем строку подключения для работы внутри Docker Compose
      # Используем имя сервиса 'db' в качестве хоста
      - ConnectionStrings__DefaultConnection=Host=db;Port=5432;Database=menti;Username=admin;Password=admin; # ВАЖНО Host=db
      # Указываем среду выполнения (по желанию)
      - ASPNETCORE_ENVIRONMENT=Development
      # Порт, который слушает Kestrel внутри контейнера (должен совпадать с EXPOSE в Dockerfile)
      - ASPNETCORE_URLS=http+8080
    depends_on
      # Указываем, что сервис API зависит от сервиса БД и должен ждать его готовности
      db
        condition service_healthy # Ждем успешного healthcheck от сервиса db

# Определяем именованный том для данных PostgreSQL
volumes
  postgres_data
    driver local # Используем стандартный драйвер Docker для томов